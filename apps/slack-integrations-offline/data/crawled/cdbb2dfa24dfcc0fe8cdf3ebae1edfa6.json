{
    "id": "cdbb2dfa24dfcc0fe8cdf3ebae1edfa6",
    "metadata": {
        "id": "cdbb2dfa24dfcc0fe8cdf3ebae1edfa6",
        "url": "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm",
        "title": "Deploy with Helm | ZenML - Bridging the gap between ML & Ops",
        "properties": {
            "description": "Deploying ZenML in a Kubernetes cluster with Helm.",
            "keywords": null,
            "author": null,
            "og:title": "Deploy with Helm | ZenML - Bridging the gap between ML & Ops",
            "og:description": "Deploying ZenML in a Kubernetes cluster with Helm.",
            "og:image": "https://docs.zenml.io/~gitbook/ogimage/bxQvlzr5MAUROsUnWdUR",
            "twitter:card": "summary_large_image",
            "twitter:title": "Deploy with Helm | ZenML - Bridging the gap between ML & Ops",
            "twitter:description": "Deploying ZenML in a Kubernetes cluster with Helm.",
            "twitter:image": "https://docs.zenml.io/~gitbook/ogimage/bxQvlzr5MAUROsUnWdUR"
        }
    },
    "content": "`Ctrl``k`\n\nGitBook AssistantAsk\n\nProductResourcesGitHubStart free\n\nMore\n\n  * Documentation\n  * Learn\n  * ZenML Pro\n  * Stacks\n  * API Reference\n  * SDK Reference\n  * Changelog\n\n\n\nGitBook Assistant\n\nGitBook Assistant\n\nWorking...Thinking...\n\nGitBook Assistant\n\n##### Good evening\n\nI'm here to help you with the docs.\n\nWhat is this page about?What should I read next?Can you give an example?\n\n`Ctrl``i`\n\nAI Based on your context\n\nSend\n\n  * Getting Started\n\n    * Welcome to ZenML\n    * Installation\n    * Hello World\n    * Your First AI Pipeline\n    * Core Concepts\n    * System Architecture\n  * Deploying ZenML\n\n    * Deploy\n\n      * Deploy with Docker\n      * Deploy with Helm\n      * Deploy using HuggingFace Spaces\n      * Deploy with custom images\n      * Secret management\n      * Custom secret stores\n\n    * Connect\n    * Manage\n  * Concepts\n\n    * Steps & Pipelines\n    * Artifacts\n    * Stack & Components\n    * Service Connectors\n    * Pipeline Snapshots\n    * Pipeline Deployments\n    * Containerization\n    * Code Repositories\n    * Secrets\n    * Environment Variables\n    * Tags\n    * Metadata\n    * Models\n    * Dashboard\n    * Templates\n  * Reference\n\n    * Community & content\n    * Environment Variables\n    * MCP Docs & llms.txt\n    * FAQ\n    * Global settings\n    * Legacy docs\n\n\n\nPowered by GitBook\n\nOn this page\n\n  * Prerequisites\n  * ZenML Helm Configuration\n  * Collect information from your SQL database service\n  * Collect information from your secrets management service\n  * Optional cluster services\n  * ZenML Helm Installation\n  * Configure the Helm chart\n  * Install the Helm chart\n  * Connect to the deployed ZenML server\n  * ZenML Helm Deployment Scenarios\n  * Minimal deployment\n  * Basic deployment with local database\n  * Shared Ingress controller\n  * Secret Store configuration\n  * Database backup and recovery\n  * Custom CA Certificates\n  * HTTP Proxy Configuration\n\n\n\nWas this helpful?\n\nGitBook AssistantAsk\n\n  1. Deploying ZenML\n  2. Deploy\n\n\n\n# Deploy with Helm\n\nDeploying ZenML in a Kubernetes cluster with Helm.\n\nIf you wish to manually deploy and manage ZenML in a Kubernetes cluster of your choice, ZenML also includes a Helm chart among its available deployment options.\n\nYou can find the chart on this ArtifactHub repository, along with the templates, default values and instructions on how to install it. Read on to find detailed explanations on prerequisites, configuration, and deployment scenarios.\n\n## \n\nPrerequisites\n\nYou'll need the following:\n\n  * A Kubernetes cluster\n\n  * Optional, but recommended: a MySQL-compatible database reachable from the Kubernetes cluster (e.g. one of the managed databases offered by Google Cloud, AWS, or Azure). A MySQL server version of 8.0 or higher is required\n\n  * the Kubernetes client already installed on your machine and configured to access your cluster\n\n  * Helm installed on your machine\n\n  * Optional: an external Secrets Manager service (e.g. one of the managed secrets management services offered by Google Cloud, AWS, Azure, or HashiCorp Vault). By default, ZenML stores secrets inside the SQL database that it's connected to, but you also have the option of using an external cloud Secrets Manager service if you already happen to use one of those cloud or service providers\n\n\n\n\n## \n\nZenML Helm Configuration\n\nYou can start by taking a look at the `values.yaml` file and familiarize yourself with some of the configuration settings that you can customize for your ZenML deployment.\n\nIn addition to tools and infrastructure, you will also need to collect and prepare information related to your database and information related to your external secrets management service to be used for the Helm chart configuration and you may also want to install additional optional services in your cluster.\n\nWhen you are ready, you can proceed to the installation section.\n\n### \n\nCollect information from your SQL database service\n\nUsing an external MySQL-compatible database service is optional, but is recommended for production deployments. If omitted, ZenML will default to using an embedded SQLite database, which has the following limitations:\n\n  * the SQLite database is not persisted, meaning that it will be lost if the ZenML server pod is restarted or deleted\n\n  * the SQLite database does not scale horizontally, meaning that you will not be able to use more than one replica at a time for the ZenML server pod\n\n\n\n\nIf you decide to use an external MySQL-compatible database service, you will need to collect and prepare the following information for the Helm chart configuration:\n\n  * the hostname and port where the SQL database is reachable from the Kubernetes cluster\n\n  * the username and password that will be used to connect to the database. It is recommended that you create a dedicated database user for the ZenML server and that you restrict its privileges to only access the database that will be used by ZenML. Enforcing secure SSL connections for the user/database is also recommended. See the MySQL documentation for more information on how to set up users and privileges.\n\n  * the name of the database that will be used by ZenML. The database does not have to exist prior to the deployment ( ZenML will create it on the first start). However, you need to create the database if you follow the best practice of restricting database user privileges to only access it.\n\n  * if you plan on using SSL to secure the client database connection, you may also need to prepare additional SSL certificates and keys:\n\n    * the TLS CA certificate that was used to sign the server TLS certificate, if you're using a self-signed certificate or signed by a custom certificate authority that is not already trusted by default by most operating systems.\n\n    * the TLS client certificate and key. This is only needed if you decide to use client certificates for your DB connection (some managed DB services support this, CloudSQL is an example).\n\n\n\n\n### \n\nCollect information from your secrets management service\n\nUsing an externally managed secrets management service like those offered by Google Cloud, AWS, Azure or HashiCorp Vault is optional, but is recommended if you are already using those cloud service providers. If omitted, ZenML will default to using the SQL database to store secrets.\n\nIf you decide to use an external secrets management service, you will need to collect and prepare the following information for the Helm chart configuration (for supported back-ends only):\n\nFor the AWS secrets manager:\n\n  * the AWS region that you want to use to store your secrets\n\n  * an AWS access key ID and secret access key that provides full access to the AWS secrets manager service. You can create a dedicated IAM user for this purpose, or use an existing user with the necessary permissions. If you deploy the ZenML server in an EKS Kubernetes cluster that is already configured to use implicit authorization with an IAM role for service accounts, you can omit this step.\n\n\n\n\nFor the Google Cloud secrets manager:\n\n  * the Google Cloud project ID that you want to use to store your secrets\n\n  * a Google Cloud service account that has access to the secrets manager service. You can create a dedicated service account for this purpose, or use an existing service account with the necessary permissions.\n\n\n\n\nFor the Azure Key Vault:\n\n  * the name of the Azure Key Vault that you want to use to store your secrets\n\n  * the Azure tenant ID, client ID, and client secret associated with the Azure service principal that will be used to access the Azure Key Vault. You can create a dedicated application service principal for this purpose, or use an existing service principal with the necessary permissions. If you deploy the ZenML server in an AKS Kubernetes cluster that is already configured to use implicit authorization through the Azure-managed identity service, you can omit this step.\n\n\n\n\nFor the HashiCorp Vault:\n\n  * the URL of the HashiCorp Vault server\n\n  * the token that will be used to access the HashiCorp Vault server.\n\n\n\n\n### \n\nOptional cluster services\n\nIt is common practice to install additional infrastructure-related services in a Kubernetes cluster to support the deployment and long-term management of applications. For example:\n\n  * an Ingress service like nginx-ingress is recommended if you want to expose HTTP services to the internet. An Ingress is required if you want to use secure HTTPS for your ZenML deployment. The alternative is to use a LoadBalancer service to expose the ZenML service using plain HTTP, but this is not recommended for production.\n\n  * a cert-manager is recommended if you want to generate and manage TLS certificates for your ZenML deployment. It can be used to automatically provision TLS certificates from a certificate authority (CA) of your choice, such as Let's Encrypt. As an alternative, the ZenML Helm chart can be configured to auto-generate self-signed or you can generate the certificates yourself and provide them to the Helm chart, but this makes it more difficult to manage the certificates and you need to manually renew them when they expire.\n\n\n\n\n## \n\nZenML Helm Installation\n\n### \n\nConfigure the Helm chart\n\nTo use the Helm chart with custom values that includes path to files like the database SSL certificates, you need to pull the chart to your local directory first. You can do this with the following command:\n\nCopy```\nhelm pull oci://public.ecr.aws/zenml/zenml --version <VERSION> --untar\n```\n\n\nNext, to customize the Helm chart for your deployment, you should create a copy of the `values.yaml` file that you can find at `./zenml/values.yaml` (let’s call this `custom-values.yaml`). You’ll use this as a template to customize your configuration. Any values that you don’t override you should simply remove from your `custom-values.yaml` file to keep it clean and compatible with future Helm chart releases.\n\nIn most cases, you’ll need to change the following configuration values in `custom-values.yaml`:\n\n  * the database configuration, if you mean to use an external database:\n\n    * the database URL, formatted as `mysql://<username>:<password>@<hostname>:<port>/<database>`\n\n    * CA and/or client TLS certificates, if you’re using SSL to secure the connection to the database can be provided in the `database.sslCa`, `database.sslCert` and `database.sslKey` fields as either an inline value or a secret reference (in the latter case, the secret(s) must be created in the same namespace as the ZenML server before the deployment).\n\n  * the Ingress configuration, if enabled:\n\n    * enabling TLS\n\n    * enabling self-signed certificates\n\n    * configuring the hostname that will be used to access the ZenML server, if different from the IP address or hostname associated with the Ingress service installed in your cluster\n\n\n\n\n### \n\nInstall the Helm chart\n\nOnce everything is configured, you can run the following command in the `./zenml` folder to install the Helm chart.\n\nCopy```\nhelm -n <namespace> install zenml-server . --create-namespace --values custom-values.yaml \n```\n\n\n### \n\nConnect to the deployed ZenML server\n\nImmediately after deployment, the ZenML server needs to be activated before it can be used. The activation process includes creating an initial admin user account and configuring some server settings. You can do this only by visiting the ZenML server URL in your browser and following the on-screen instructions. Connecting your local ZenML client to the server is not possible until the server is properly initialized.\n\nThe Helm chart should print out a message with the URL of the deployed ZenML server. You can use the URL to open the ZenML UI in your browser.\n\nTo connect your local client to the ZenML server, you can run:\n\nCopy```\nzenml login https://zenml.example.com:8080 --no-verify-ssl\n```\n\n\nTo disconnect from the current ZenML server and revert to using the local default database, use the following command:\n\nCopy```\nzenml logout\n```\n\n\n## \n\nZenML Helm Deployment Scenarios\n\nThis section covers some common Helm deployment scenarios for ZenML.\n\n### \n\nMinimal deployment\n\nThe example below is a minimal configuration for a ZenML server deployment that uses a temporary SQLite database and a ClusterIP service that is not exposed to the internet:\n\nCopy```\nzenml:\n ingress:\n  enabled: false\n```\n\n\nOnce deployed, you have to use port-forwarding to access the ZenML server and to connect to it from your local machine:\n\nCopy```\nkubectl -n zenml-server port-forward svc/zenml-server 8080:8080\nzenml login http://localhost:8080\n```\n\n\nThis is just a simple example only fit for testing and evaluation purposes. For production deployments, you should use an external database and an Ingress service with TLS certificates to secure and expose the ZenML server to the internet.\n\n### \n\nBasic deployment with local database\n\nThis deployment use-case still uses a local database, but it exposes the ZenML server to the internet using an Ingress service with TLS certificates generated by the cert-manager and signed by Let's Encrypt.\n\nFirst, you need to install cert-manager and nginx-ingress in your Kubernetes cluster. You can use the following commands to install them with their default configuration:\n\nCopy```\nhelm repo add jetstack https://charts.jetstack.io\nhelm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx\nhelm repo update\nhelm install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace --set installCRDs=true\nhelm install nginx-ingress ingress-nginx/ingress-nginx --namespace nginx-ingress --create-namespace\n```\n\n\nNext, you need to create a ClusterIssuer resource that will be used by cert-manager to generate TLS certificates with Let's Encrypt:\n\nCopy```\ncat <<EOF | kubectl apply -f -\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n name: letsencrypt-staging\n namespace: cert-manager\nspec:\n acme:\n  server: https://acme-v02.api.letsencrypt.org/directory\n  email: <your email address here>\n  privateKeySecretRef:\n   name: letsencrypt-staging\n  solvers:\n  - http01:\n    ingress:\n     class: nginx\nEOF\n```\n\n\nFinally, you can deploy the ZenML server with the following Helm values:\n\nCopy```\nzenml:\n ingress:\n  enabled: true\n  annotations:\n   cert-manager.io/cluster-issuer: \"letsencrypt-staging\"\n  tls:\n   enabled: true\n   generateCerts: false\n```\n\n\n> **Note** This use-case exposes ZenML at the root URL path of the IP address or hostname of the Ingress service. You cannot share the same Ingress hostname and URL path for multiple applications. See the next section for a solution to this problem.\n\n### \n\nShared Ingress controller\n\nIf the root URL path of your Ingress controller is already in use by another application, you cannot use it for ZenML. This section presents three possible solutions to this problem.\n\n#### \n\nUse a dedicated Ingress hostname for ZenML\n\nIf you know the IP address of the load balancer in use by your Ingress controller, you can use a service like https://nip.io/ to create a new DNS name associated with it and expose ZenML at this new root URL path. For example, if your Ingress controller has the IP address `192.168.10.20`, you can use a DNS name like `zenml.192.168.10.20.nip.io` to expose ZenML at the root URL path `https://zenml.192.168.10.20.nip.io`.\n\nTo find the IP address of your Ingress controller, you can use a command like the following:\n\nCopy```\nkubectl -n nginx-ingress get svc nginx-ingress-ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}'\n```\n\n\nYou can deploy the ZenML server with the following Helm values:\n\nCopy```\nzenml:\n ingress:\n  enabled: true\n  annotations:\n   cert-manager.io/cluster-issuer: \"letsencrypt-staging\"\n  host: zenml.<nginx ingress IP address>.nip.io\n  tls:\n   enabled: true\n   generateCerts: false\n```\n\n\n> **Note** This method does not work if your Ingress controller is behind a load balancer that uses a hostname mapped to several IP addresses instead of an IP address.\n\n#### \n\nUse a dedicated Ingress URL path for ZenML\n\nIf you cannot use a dedicated Ingress hostname for ZenML, you can use a dedicated Ingress URL path instead. For example, you can expose ZenML at the URL path `https://<your ingress hostname>/zenml`.\n\nTo deploy the ZenML server with a dedicated Ingress URL path, you can use the following Helm values:\n\nCopy```\nzenml:\n ingress:\n  enabled: true\n  annotations:\n   cert-manager.io/cluster-issuer: \"letsencrypt-staging\"\n   nginx.ingress.kubernetes.io/rewrite-target: /$1\n  path: /zenml/?(.*)\n  tls:\n   enabled: true\n   generateCerts: false\n```\n\n\n> **Note** This method has one current limitation: the ZenML UI does not support URL rewriting and will not work properly if you use a dedicated Ingress URL path. You can still connect your client to the ZenML server and use it to run pipelines as usual, but you will not be able to use the ZenML UI.\n\n#### \n\nUse a DNS service to map a different hostname to the Ingress controller\n\nThis method requires you to configure a DNS service like AWS Route 53 or Google Cloud DNS to map a different hostname to the Ingress controller. For example, you can map the hostname `zenml.<subdomain>` to the Ingress controller's IP address or hostname. Then, simply use the new hostname to expose ZenML at the root URL path.\n\n### \n\nSecret Store configuration\n\nUnless explicitly disabled or configured otherwise, the ZenML server will use the SQL database as a secrets store backend where secret values are stored. If you want to use an external secrets management service like the AWS Secrets Manager, GCP Secrets Manager, Azure Key Vault, HashiCorp Vault or even your custom Secrets Store back-end implementation instead, you need to configure it in the Helm values. Depending on where you deploy your ZenML server and how your Kubernetes cluster is configured, you will also need to provide the credentials needed to access the secrets management service API.\n\n> **Important:** If you are updating the configuration of your ZenML Server deployment to use a different secrets store back-end or location, you should follow the documented secrets migration strategy to minimize downtime and to ensure that existing secrets are also properly migrated.\n\nAWS\n\nAWS\n\nGCP\n\nAzure\n\nHashicorp\n\nCustom\n\n**Using the SQL database as a secrets store backend (default)**\n\nThe SQL database is used as the default location where the ZenML secrets store keeps the secret values. You only need to configure these options if you want to change the default behavior.\n\nIt is particularly recommended to enable encryption at rest for the SQL database if you plan on using it as a secrets store backend. You'll have to configure the secret key used to encrypt the secret values. If not set, encryption will not be used and passwords will be stored unencrypted in the database. This value should be set to a random string with a recommended length of at least 32 characters, e.g.:\n\n  * generate a random string with Python:\n\n\n\n\nCopy```\nfrom secrets import token_hex\ntoken_hex(32)\n```\n\n\n  * or with OpenSSL:\n\n\n\n\nCopy```\nopenssl rand -hex 32\n```\n\n\n  * then configure it in the Helm values:\n\n\n\n\nCopy```\n zenml:\n  # ...\n  # Secrets store settings. This is used to store centralized secrets.\n  secretsStore:\n   # The type of the secrets store\n   type: sql\n   # Configuration for the SQL secrets store\n   sql:\n    encryptionKey: 0f00e4282a3181be32c108819e8a860a429b613e470ad58531f0730afff64545\n```\n\n\n> **Important:** If you configure encryption for your SQL database secrets store, you should keep the `encryptionKey` value somewhere safe and secure, as it will always be required by the ZenML Server to decrypt the secrets in the database. If you lose the encryption key, you will not be able to decrypt the secrets anymore and will have to reset them.\n\n**Using the AWS Secrets Manager as a secrets store backend**\n\nThe AWS Secrets Store uses the ZenML AWS Service Connector under the hood to authenticate with the AWS Secrets Manager API. This means that you can use any of the authentication methods supported by the AWS Service Connector to authenticate with the AWS Secrets Manager API.\n\nThe minimum set of permissions that must be attached to the implicit or configured AWS credentials are: `secretsmanager:CreateSecret`, `secretsmanager:GetSecretValue`, `secretsmanager:DescribeSecret`, `secretsmanager:PutSecretValue`, `secretsmanager:TagResource` and `secretsmanager:DeleteSecret` and they must be associated with secrets that have a name starting with `zenml/` in the target region and account. The following IAM policy example can be used as a starting point:\n\nCopy```\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"ZenMLSecretsStore\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"secretsmanager:CreateSecret\",\n        \"secretsmanager:GetSecretValue\",\n        \"secretsmanager:DescribeSecret\",\n        \"secretsmanager:PutSecretValue\",\n        \"secretsmanager:TagResource\",\n        \"secretsmanager:DeleteSecret\"\n      ],\n      \"Resource\": \"arn:aws:secretsmanager:<AWS-region>:<AWS-account-id>:secret:zenml/*\"\n    }\n  ]\n}\n```\n\n\nExample configuration for the AWS Secrets Store:\n\nCopy```\n zenml:\n  # ...\n  # Secrets store settings. This is used to store centralized secrets.\n  secretsStore:\n   # Set to false to disable the secrets store.\n   enabled: true\n   # The type of the secrets store\n   type: aws\n   # Configuration for the AWS Secrets Manager secrets store\n   aws:\n    # The AWS Service Connector authentication method to use.\n    authMethod: secret-key\n    # The AWS Service Connector configuration.\n    authConfig:\n    # The AWS region to use. This must be set to the region where the AWS\n    # Secrets Manager service that you want to use is located.\n    region: us-east-1\n    # The AWS credentials to use to authenticate with the AWS Secrets\n    aws_access_key_id: <your AWS access key ID>\n    aws_secret_access_key: <your AWS secret access key>\n```\n\n\n**Using the GCP Secrets Manager as a secrets store backend**\n\nThe GCP Secrets Store uses the ZenML GCP Service Connector under the hood to authenticate with the GCP Secrets Manager API. This means that you can use any of the authentication methods supported by the GCP Service Connector to authenticate with the GCP Secrets Manager API.\n\nThe minimum set of permissions that must be attached to the implicit or configured GCP credentials are as follows:\n\n  * `secretmanager.secrets.create` for the target GCP project (i.e. no condition on the name prefix)\n\n  * `secretmanager.secrets.get`, `secretmanager.secrets.update`, `secretmanager.versions.access`, `secretmanager.versions.add` and `secretmanager.secrets.delete` for the target GCP project and for secrets that have a name starting with `zenml-`\n\n\n\n\nThis can be achieved by creating two custom IAM roles and attaching them to the principal (e.g. user or service account) that will be used to access the GCP Secrets Manager API with a condition configured when attaching the second role to limit access to secrets with a name prefix of `zenml-`. The following `gcloud` CLI command examples can be used as a starting point:\n\nCopy```\ngcloud iam roles create ZenMLServerSecretsStoreCreator \\\n --project <your GCP project ID> \\\n --title \"ZenML Server Secrets Store Creator\" \\\n --description \"Allow the ZenML Server to create new secrets\" \\\n --stage GA \\\n --permissions \"secretmanager.secrets.create\"\ngcloud iam roles create ZenMLServerSecretsStoreEditor \\\n --project <your GCP project ID> \\\n --title \"ZenML Server Secrets Store Editor\" \\\n --description \"Allow the ZenML Server to manage its secrets\" \\\n --stage GA \\\n --permissions \"secretmanager.secrets.get,secretmanager.secrets.update,secretmanager.versions.access,secretmanager.versions.add,secretmanager.secrets.delete\"\ngcloud projects add-iam-policy-binding <your GCP project ID> \\\n --member serviceAccount:<your GCP service account email> \\\n --role projects/<your GCP project ID>/roles/ZenMLServerSecretsStoreCreator \\\n --condition None\n# NOTE: use the GCP project NUMBER, not the project ID in the condition\ngcloud projects add-iam-policy-binding <your GCP project ID> \\\n --member serviceAccount:<your GCP service account email> \\\n --role projects/<your GCP project ID>/roles/ZenMLServerSecretsStoreEditor \\\n --condition 'title=limit_access_zenml,description=\"Limit access to secrets with prefix zenml-\",expression=resource.name.startsWith(\"projects/<your GCP project NUMBER>/secrets/zenml-\")'\n```\n\n\nExample configuration for the GCP Secrets Store:\n\nCopy```\n zenml:\n  # ...\n  # Secrets store settings. This is used to store centralized secrets.\n  secretsStore:\n   # Set to false to disable the secrets store.\n   enabled: true\n   # The type of the secrets store\n   type: gcp\n   # Configuration for the GCP Secrets Manager secrets store\n   gcp:\n    # The GCP Service Connector authentication method to use.\n    authMethod: service-account\n    # The GCP Service Connector configuration.\n    authConfig:\n     # The GCP project ID to use. This must be set to the project ID where the\n     # GCP Secrets Manager service that you want to use is located.\n     project_id: my-gcp-project\n     # GCP credentials JSON to use to authenticate with the GCP Secrets\n     # Manager instance. \n     google_application_credentials: |\n      {\n       \"type\": \"service_account\",\n       \"project_id\": \"my-project\",\n       \"private_key_id\": \"...\",\n       \"private_key\": \"-----BEGIN PRIVATE KEY-----\\n...=\\n-----END PRIVATE KEY-----\\n\",\n       \"client_email\": \"...\",\n       \"client_id\": \"...\",\n       \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",\n       \"token_uri\": \"https://oauth2.googleapis.com/token\",\n       \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\",\n       \"client_x509_cert_url\": \"...\"\n      }\n serviceAccount:\n  # If you're using workload identity, you need to annotate the service\n  # account with the GCP service account name (see https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)\n  annotations:\n   iam.gke.io/gcp-service-account: <SERVICE_ACCOUNT_NAME>@<PROJECT_NAME>.iam.gserviceaccount.com\n\n```\n\n\n**Using the Azure Key Vault as a secrets store backend**\n\nThe Azure Secrets Store uses the ZenML Azure Service Connector under the hood to authenticate with the Azure Key Vault API. This means that you can use any of the authentication methods supported by the Azure Service Connector to authenticate with the Azure Key Vault API.\n\nExample configuration for the Azure Key Vault Secrets Store:\n\nCopy```\n zenml:\n  # ...\n  # Secrets store settings. This is used to store centralized secrets.\n  secretsStore:\n   # Set to false to disable the secrets store.\n   enabled: true\n   # The type of the secrets store\n   type: azure\n   # Configuration for the Azure Key Vault secrets store\n   azure:\n    # The name of the Azure Key Vault. This must be set to point to the Azure\n    # Key Vault instance that you want to use.\n    key_vault_name:\n    # The Azure Service Connector authentication method to use.\n    authMethod: service-principal\n    # The Azure Service Connector configuration.\n    authConfig:\n     # The Azure application service principal credentials to use to\n     # authenticate with the Azure Key Vault API.\n     client_id: <your Azure client ID>\n     client_secret: <your Azure client secret>\n     tenant_id: <your Azure tenant ID>\n```\n\n\n**Using the HashiCorp Vault as a secrets store backend**\n\nTo use the HashiCorp Vault service as a Secrets Store back-end, it must be configured in the Helm values:\n\nCopy```\n zenml:\n  # ...\n  # Secrets store settings. This is used to store centralized secrets.\n  secretsStore:\n   # Set to false to disable the secrets store.\n   enabled: true\n   # The type of the secrets store\n   type: hashicorp\n   # Configuration for the HashiCorp Vault secrets store\n   hashicorp:\n    # The url of the HashiCorp Vault server to use\n    vault_addr: https://vault.example.com\n    # The token used to authenticate with the Vault server\n    vault_token: <your Vault token>\n    # The Vault Enterprise namespace. Not required for Vault OSS.\n    vault_namespace: <your Vault namespace>\n    # The mount point to use for the HashiCorp Vault secrets store. If not set, the default value of `secret` will be used.\n    mount_point: <your Vault mount point>\n```\n\n\n**Using a custom secrets store backend implementation**\n\nYou have the option of using a custom implementation of the secrets store API as your secrets store back-end. This must come in the form of a class derived from `zenml.zen_stores.secrets_stores.base_secrets_store.BaseSecretsStore`. This class must be importable from within the ZenML server container, which means you most likely need to build a custom container image that contains the class. Then, you can configure the Helm values to use your custom secrets store as follows:\n\nCopy```\n zenml:\n  # ...\n  # Secrets store settings. This is used to store centralized secrets.\n  secretsStore:\n   # Set to false to disable the secrets store.\n   enabled: true\n   # The type of the secrets store\n   type: custom\n   # Configuration for the HashiCorp Vault secrets store\n   custom:\n    # The class path of the custom secrets store implementation. This should\n    # point to a full Python class that extends the\n    # `zenml.zen_stores.secrets_stores.base_secrets_store.BaseSecretsStore`\n    # base class. The class should be importable from the container image\n    # that you are using for the ZenML server.\n    class_path: my.custom.secrets.store.MyCustomSecretsStore\n  # Extra environment variables used to configure the custom secrets store.\n  environment:\n   ZENML_SECRETS_STORE_OPTION_1: value1\n   ZENML_SECRETS_STORE_OPTION_2: value2\n  # Extra environment variables to set in the ZenML server container that\n  # should be kept secret and are used to configure the custom secrets store.\n  secretEnvironment:\n   ZENML_SECRETS_STORE_SECRET_OPTION_3: value3\n   ZENML_SECRETS_STORE_SECRET_OPTION_4: value4\n```\n\n\n#### \n\nBackup secrets store\n\nA backup secrets store back-end may be configured for high-availability and backup purposes. or as an intermediate step in the process of migrating secrets to a different external location or secrets manager provider.\n\nTo configure a backup secrets store in the Helm chart, use the same approach and instructions documented for the primary secrets store, but using the `backupSecretsStore` configuration section instead of `secretsStore`, e.g.:\n\nCopy```\n zenml:\n  # ...\n  # Backup secrets store settings. This is used as a backup for the primary\n  # secrets store.\n  backupSecretsStore:\n   # Set to true to enable the backup secrets store.\n   enabled: true\n   # The type of the backup secrets store\n   type: aws\n   # Configuration for the AWS Secrets Manager backup secrets store\n   aws:\n    # The AWS Service Connector authentication method to use.\n    authMethod: secret-key\n    # The AWS Service Connector configuration.\n    authConfig:\n    # The AWS region to use. This must be set to the region where the AWS\n    # Secrets Manager service that you want to use is located.\n    region: us-east-1\n    # The AWS credentials to use to authenticate with the AWS Secrets\n    aws_access_key_id: <your AWS access key ID>\n    aws_secret_access_key: <your AWS secret access key>\n```\n\n\n### \n\nDatabase backup and recovery\n\nAn automated database backup and recovery feature is enabled by default for all Helm deployments. The ZenML server will automatically back up the database before every upgrade and restore it if the upgrade fails in a way that affects the database.\n\nThe database backup automatically created by the ZenML server is only temporary and only used as an immediate recovery in case of database migration failures. It is not meant to be used as a long-term backup solution. If you need to back up your database for long-term storage, you should use a dedicated backup solution.\n\nSeveral database backup strategies are supported, depending on where and how the backup is stored. The strategy can be configured by means of the `zenml.database.backupStrategy` Helm value:\n\n  * `disabled` - no backup is performed\n\n  * `in-memory` - the database schema and data are stored in memory. This is the fastest backup strategy, but the backup is not persisted across pod restarts, so no manual intervention is possible in case the automatic DB recovery fails after a failed DB migration. Adequate memory resources should be allocated to the ZenML server pod when using this backup strategy with larger databases. This is the default backup strategy.\n\n  * `database` - the database is copied to a backup database in the same database server. This requires the `backupDatabase` option to be set to the name of the backup database. This backup strategy is only supported for MySQL compatible databases and the user specified in the database URL must have permissions to manage (create, drop, and modify) the backup database in addition to the main database.\n\n  * `dump-file` - the database schema and data are dumped to a file local to the database initialization and upgrade job. Users may optionally configure a persistent volume where the dump file will be stored by setting the `backupPVStorageSize` and optionally the `backupPVStorageClass` options. If a persistent volume is not configured, the dump file will be stored in an emptyDir volume, which is not persisted. If configured, the user is responsible for deleting the resulting PVC when uninstalling the Helm release.\n\n\n\n\n> **NOTE:** You should also set the `podSecurityContext.fsGroup` option if you are using a persistent volume to store the dump file.\n\nThe following additional rules are applied concerning the creation and lifetime of the backup:\n\n  * a backup is not attempted if the database doesn't need to undergo a migration (e.g. when the ZenML server is upgraded to a new version that doesn't require a database schema change or if the ZenML version doesn't change at all).\n\n  * a backup file or database is created before every database migration attempt (i.e. during every Helm upgrade). If a backup already exists (i.e. persisted in a persistent volume or backup database), it is overwritten.\n\n  * the persistent backup file or database is cleaned up after the migration is completed successfully or if the database doesn't need to undergo a migration. This includes backups created by previous failed migration attempts.\n\n  * the persistent backup file or database is NOT cleaned up after a failed migration. This allows the user to manually inspect and/or apply the backup if the automatic recovery fails.\n\n\n\n\nThe following example shows how to configure the ZenML server to use a persistent volume to store the database dump file:\n\nCopy```\n zenml:\n  # ...\n database:\n  url: \"mysql://admin:password@my.database.org:3306/zenml\"\n  # Configure the database backup strategy\n  backupStrategy: dump-file\n  backupPVStorageSize: 1Gi\npodSecurityContext:\n fsGroup: 1000 # if you're using a PVC for backup, this should necessarily be set.\n```\n\n\n### \n\nCustom CA Certificates\n\nIf you need to connect to services using HTTPS with certificates signed by custom Certificate Authorities (e.g., self-signed certificates), you can configure custom CA certificates. There are two ways to provide custom CA certificates:\n\n  1. Direct injection in values.yaml:\n\n\n\n\nCopy```\nzenml:\n certificates:\n  customCAs:\n   - name: \"my-custom-ca\"\n    certificate: |\n     -----BEGIN CERTIFICATE-----\n     MIIDXTCCAkWgAwIBAgIJAJC1HiIAZAiIMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV\n     ...\n     -----END CERTIFICATE-----\n```\n\n\n  1. Reference existing Kubernetes secrets:\n\n\n\n\nCopy```\nzenml:\n certificates:\n  secretRefs:\n   - name: \"my-secret\"\n    key: \"ca.crt\"\n```\n\n\nThe certificates will be installed in the server container, allowing it to securely connect to services using these custom CA certificates.\n\n### \n\nHTTP Proxy Configuration\n\nIf your environment requires a proxy for external connections, you can configure it using:\n\nCopy```\nzenml:\n proxy:\n  enabled: true\n  httpProxy: \"http://proxy.example.com:8080\"\n  httpsProxy: \"http://proxy.example.com:8080\"\n  # Additional hostnames/domains/IPs/CIDRs to exclude from proxying\n  additionalNoProxy:\n   - \"internal.example.com\"\n   - \"10.0.0.0/8\"\n```\n\n\nBy default, the following hostnames/domains are excluded from proxying:\n\n  * `localhost`, `127.0.0.1`, `::1` (IPv4 and IPv6 localhost)\n\n  * `fe80::/10` (IPv6 link-local addresses)\n\n  * `.svc` and `.svc.cluster.local` (Kubernetes service DNS domains)\n\n  * The hostname from `zenml.serverURL` if configured\n\n  * The ingress hostname (`zenml.ingress.host`) if configured\n\n  * Internal service names used for communication between components\n\n\n\n\nYou can add additional exclusions using the `additionalNoProxy` list. The NO_PROXY environment variable accepts:\n\n  * Hostnames (e.g., \"zenml.example.com\")\n\n  * Domain names with leading dot for wildcards (e.g., \".example.com\")\n\n  * IPv4 addresses (e.g., \"10.0.0.1\")\n\n  * IPv4 ranges in CIDR notation (e.g., \"10.0.0.0/8\")\n\n  * IPv6 addresses (e.g., \"::1\")\n\n  * IPv6 ranges in CIDR notation (e.g., \"fe80::/10\")\n\n\n\n\nPreviousDeploy with DockerNextDeploy using HuggingFace Spaces\n\nLast updated 1 month ago\n\nWas this helpful?\n\nThis site uses cookies to deliver its service and to analyze traffic. By browsing this site, you accept the privacy policy.\n\nAcceptReject\n",
    "summary": null,
    "content_quality_score": null,
    "child_urls": [
        "https://docs.zenml.io/",
        "https://zenml.io",
        "https://zenml.io/slack",
        "https://cloud.zenml.io/signup",
        "https://docs.zenml.io/user-guides",
        "https://docs.zenml.io/pro",
        "https://docs.zenml.io/stacks",
        "https://docs.zenml.io/api-reference",
        "https://docs.zenml.io/sdk-reference",
        "https://docs.zenml.io/changelog",
        "https://docs.zenml.io/getting-started/installation",
        "https://docs.zenml.io/getting-started/hello-world",
        "https://docs.zenml.io/getting-started/your-first-ai-pipeline",
        "https://docs.zenml.io/getting-started/core-concepts",
        "https://docs.zenml.io/getting-started/system-architectures",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-docker",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-using-huggingface-spaces",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-custom-image",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/secret-management",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/custom-secret-stores",
        "https://docs.zenml.io/deploying-zenml/connecting-to-zenml",
        "https://docs.zenml.io/deploying-zenml/upgrade-zenml-server",
        "https://docs.zenml.io/concepts/steps_and_pipelines",
        "https://docs.zenml.io/concepts/artifacts",
        "https://docs.zenml.io/concepts/stack_components",
        "https://docs.zenml.io/concepts/service_connectors",
        "https://docs.zenml.io/concepts/snapshots",
        "https://docs.zenml.io/concepts/deployment",
        "https://docs.zenml.io/concepts/containerization",
        "https://docs.zenml.io/concepts/code-repositories",
        "https://docs.zenml.io/concepts/secrets",
        "https://docs.zenml.io/concepts/environment-variables",
        "https://docs.zenml.io/concepts/tags",
        "https://docs.zenml.io/concepts/metadata",
        "https://docs.zenml.io/concepts/models",
        "https://docs.zenml.io/concepts/dashboard-features",
        "https://docs.zenml.io/concepts/templates",
        "https://docs.zenml.io/reference/community-and-content",
        "https://docs.zenml.io/reference/environment-variables",
        "https://docs.zenml.io/reference/llms-txt",
        "https://docs.zenml.io/reference/faq",
        "https://docs.zenml.io/reference/global-settings",
        "https://docs.zenml.io/reference/legacy-docs",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#prerequisites",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#zenml-helm-configuration",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#collect-information-from-your-sql-database-service",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#collect-information-from-your-secrets-management-service",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#optional-cluster-services",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#zenml-helm-installation",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#configure-the-helm-chart",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#install-the-helm-chart",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#connect-to-the-deployed-zenml-server",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#zenml-helm-deployment-scenarios",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#minimal-deployment",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#basic-deployment-with-local-database",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#shared-ingress-controller",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#secret-store-configuration",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#database-backup-and-recovery",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#custom-ca-certificates",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#http-proxy-configuration",
        "https://docs.zenml.io/deploying-zenml",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#use-a-dedicated-ingress-hostname-for-zenml",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#use-a-dedicated-ingress-url-path-for-zenml",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#use-a-dns-service-to-map-a-different-hostname-to-the-ingress-controller",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/secret-management#secrets-migration-strategy",
        "https://docs.zenml.io/stacks/service-connectors/connector-types/aws-service-connector#authentication-methods",
        "https://docs.zenml.io/stacks/service-connectors/connector-types/gcp-service-connector#authentication-methods",
        "https://docs.zenml.io/stacks/service-connectors/connector-types/azure-service-connector#authentication-methods",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/deploy-with-helm#backup-secrets-store",
        "https://docs.zenml.io/deploying-zenml/deploying-zenml/secret-management#backup-secrets-store",
        "https://www.zenml.io/privacy-policy",
        "https://github.com/zenml-io/zenml",
        "https://www.gitbook.com/?utm_source=content&utm_medium=trademark&utm_campaign=5aBlTJNbVDkrxJp7J1J9",
        "https://artifacthub.io/packages/helm/zenml/zenml",
        "https://kubernetes.io/docs/tasks/tools/#kubectl",
        "https://helm.sh/docs/intro/install/",
        "https://artifacthub.io/packages/helm/zenml/zenml?modal=values",
        "https://dev.mysql.com/doc/refman/5.7/en/access-control.html",
        "https://kubernetes.github.io/ingress-nginx/deploy/",
        "https://cert-manager.io/docs/installation/",
        "https://letsencrypt.org/"
    ]
}